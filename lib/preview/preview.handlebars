<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plot Preview</title>
    <style>
      * {
        box-sizing: border-box;
      }
      html {
        background: #090d17;
      }
      body {
        margin: 0;
        text-align: center;
      }
      canvas {
        border: 1px solid #bb5264;
        max-width: 1200px;
      }
    </style>
  </head>
  <body>
    <script>
      const pathList = {{{pathList}}}

      const dimensionPadding = 48;
      const scale = 4;

      const { width, height } = {{{workArea}}};
      const boundingBox = {{{boundingBox}}};

      boundingBox.minX = boundingBox.minX * scale;
      boundingBox.maxX = boundingBox.maxX * scale;
      boundingBox.minY = boundingBox.minY * scale;
      boundingBox.maxY = boundingBox.maxY * scale;

      // scale the dimensions for a higher resolution
      const scaledWidth = width * scale;
      const scaledHeight = height * scale;

      const canvas = document.createElement('canvas');
      canvas.width = scaledWidth + dimensionPadding;
      canvas.height = scaledHeight + dimensionPadding;
      const ctx = canvas.getContext('2d');

      const colors = {
        dimensions: '#bb5264',
        penDown: '#dedede',
        penUp: 'aqua',
        background: '#141926',
      };

      ctx.fillStyle = colors.background;
      ctx.fillRect(
        0,
        0,
        scaledWidth + dimensionPadding,
        scaledHeight + dimensionPadding
      );

      // Draw the dimensions outline
      ctx.strokeStyle = colors.dimensions;
      ctx.fillStyle = colors.dimensions;
      ctx.strokeRect(0, 0, scaledWidth, scaledHeight);

      // Draw dimensions text
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '24px Helvetica';

      ctx.fillText(
        `${width}mm`,
        scaledWidth * 0.5,
        scaledHeight + dimensionPadding * 0.5
      );

      ctx.save();
      ctx.translate(scaledWidth + dimensionPadding * 0.5, scaledHeight * 0.5);
      ctx.rotate(Math.PI * 0.5);
      ctx.fillText(`${height}mm`, 0, 0);
      ctx.restore();

      // Scaling here makes drawing a little cleaner in the next step
      const scaledPathList = pathList.map((path) =>
        path.map((value) => value * scale)
      );

      // Draw lines
      let lastPosition = [0, 0];

      scaledPathList.forEach((path) => {
        // Draw pen up movement
        ctx.beginPath();
        ctx.moveTo(lastPosition[0], lastPosition[1]);
        ctx.strokeStyle = colors.penUp;
        ctx.lineTo(path[0], path[1]);
        ctx.stroke();

        // Draw pen down movement
        ctx.strokeStyle = colors.penDown;
        ctx.beginPath();
        ctx.moveTo(path[0], path[1]);
        for (let i = 2; i < path.length; i += 2) {
          const x = path[i];
          const y = path[i + 1];

          ctx.lineTo(x, y);

          lastPosition = [x, y];
        }
        // Actually closing the path helps prevent weird artifacts
        if (path[0] === lastPosition[0] && path[1] === lastPosition[1]) {
          ctx.closePath();
        }
        ctx.stroke();
      });

      // Draw bounding box
      ctx.strokeStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(boundingBox.minX, boundingBox.minY);
      ctx.lineTo(boundingBox.maxX, boundingBox.minY);
      ctx.lineTo(boundingBox.maxX, boundingBox.maxY);
      ctx.lineTo(boundingBox.minX, boundingBox.maxY);
      ctx.closePath();
      ctx.stroke();

      document.body.appendChild(canvas);
    </script>
  </body>
</html>
